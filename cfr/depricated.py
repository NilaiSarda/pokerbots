EVBUCKETS = ((0.41925843940232427, 0.4245742092457421, 0.4257149240393208, 0.42717134166948295, 0.4313890761968982, 0.433231340837067, 0.4347304082078149, 0.43764358385297014, 0.43807364812562205, 0.4401570386988222, 0.4444923474886829, 0.44573211499888565, 0.4488307349665924, 0.45202952029520294, 0.4533190336419056, 0.45362479247371335, 0.454329908546912, 0.4546051911072172, 0.4568452380952381, 0.45703728215309947, 0.46078431372549017, 0.46384205856255545, 0.4638729945024122, 0.4654032613486117, 0.4666329625884732, 0.4671199286669639, 0.47117329737019553, 0.4723861485357978, 0.4736346516007533, 0.4772950551249864, 0.47753852880096187, 0.47959866220735786, 0.4804355034818172, 0.48163355898346466, 0.48260186328431925, 0.4838162930563149, 0.4843422648583085, 0.48448179271708686, 0.4868204283360791, 0.4888596202392712, 0.49250873042694604, 0.49300852086519553, 0.4945858450546997, 0.4948985129708021, 0.4975027746947836, 0.49983090970578287, 0.5001644376233282, 0.5035879885184368, 0.5038616521155138, 0.5039602855867916, 0.5054808452932534, 0.5059260079751883, 0.5060332644852701, 0.5060559348161198, 0.5075434568711052, 0.508544621914442, 0.5086714659685864, 0.509068790090688, 0.5097125097125097, 0.5112682280159081, 0.5120703081544109, 0.5125919322487186, 0.5132182652392396, 0.5152449091909741, 0.5153157138117881, 0.5160969133753733, 0.5200598470575196, 0.5210882163554411, 0.5237992444684296, 0.5238436123348018, 0.5252695417789758, 0.526819496995326, 0.527172729252886, 0.5272341813437704, 0.5296041871115472, 0.5298515728843598, 0.5299758877685226, 0.5301824212271974, 0.5329738231659364, 0.5330320276754826, 0.5342361035273562, 0.5356905710491368, 0.5357610117749673, 0.5377262443438914, 0.53836784409257, 0.539190071848465, 0.5405537991932846, 0.5416253170140037, 0.5457350672250386, 0.5494505494505495, 0.5524359116635223, 0.5536284550159674, 0.5574991722767907, 0.5618064802485575, 0.5618729096989966, 0.5687006145741879, 0.5723552894211577, 0.5814337628014535, 0.6240641711229946),
(0.2390466175955135, 0.24848185284564328, 0.2565023078613818, 0.2629032258064516, 0.2697594501718213, 0.2759891078007368, 0.2822599809885932, 0.28813367957547703, 0.29349537182797053, 0.29933454325468845, 0.3044982698961938, 0.3092322185586434, 0.3136863933641729, 0.3180209930416323, 0.32228884523932594, 0.3261604359101372, 0.33009071004066315, 0.3338829939776312, 0.3375181620050854, 0.34127671865973425, 0.34496562330378144, 0.3479145067389744, 0.35086878140462585, 0.35381679389312976, 0.3565084183601765, 0.3594146116616732, 0.36221161495624504, 0.36490384615384613, 0.3673708920187793, 0.37000549224220786, 0.37248995983935745, 0.37484737484737485, 0.3774113019139118, 0.3797304302747538, 0.38204776820673453, 0.38434982738780205, 0.38678031521389517, 0.3889794708367302, 0.391378443314522, 0.3937113569801497, 0.3958884908892696, 0.3981009586215265, 0.4006182380216383, 0.40321972756151403, 0.406056789558049, 0.4087620180394489, 0.4112947658402204, 0.4139843003696474, 0.4169238498528673, 0.420060706401766, 0.4234111611349597, 0.4266666666666667, 0.43047285464098073, 0.4339591567852437, 0.4372874149659864, 0.44091688521283035, 0.44451947682684106, 0.4484246830723341, 0.4526688907422852, 0.4571777855396437, 0.4618045021539955, 0.4657534246575342, 0.47010543973160795, 0.47392851616896176, 0.4775442574343769, 0.48170854948460556, 0.48577364285069097, 0.4899751321106621, 0.49455782312925173, 0.4987060896377051, 0.5029508196721312, 0.5077150218568162, 0.513086345981476, 0.5191167450419137, 0.5247321571344811, 0.5307971014492754, 0.5377597421285903, 0.5449934475561812, 0.5525061733743447, 0.5601799775028121, 0.5689004770886498, 0.5770360374662645, 0.5844041541982046, 0.5923131704277385, 0.5999057492931197, 0.6082810936100722, 0.6188455008488964, 0.6296923567386626, 0.6413030718059088, 0.6534591194968553, 0.6647256438969765, 0.6771069883028408, 0.6900785530398046, 0.7034913213206591, 0.7210344125432702, 0.7410308538627123, 0.7891610834806199, 0.8531181112095428, 0.8784694742792538),
(0.06528662420382166, 0.085, 0.1, 0.11264822134387352, 0.1238003838771593, 0.13352272727272727, 0.14204545454545456, 0.15, 0.15782312925170067, 0.16574585635359115, 0.17331670822942644, 0.1808189655172414, 0.18801313628899835, 0.19488188976377951, 0.20161290322580644, 0.2081174438687392, 0.21458333333333332, 0.2208148341603552, 0.22657450076804916, 0.2322801024765158, 0.23796583850931677, 0.24362709395484342, 0.24933804060017653, 0.2547892720306513, 0.26056945642795515, 0.26655982905982906, 0.2727272727272727, 0.27871621621621623, 0.2847014925373134, 0.29062811565304086, 0.2964824120603015, 0.3024439918533605, 0.30831099195710454, 0.31397006414825374, 0.319852153417613, 0.32558139534883723, 0.3313843832516032, 0.33722527472527475, 0.3428417653390743, 0.3484154257350134, 0.35383931218499853, 0.35918367346938773, 0.36461199779856907, 0.370145063172672, 0.37569573283859, 0.3814852492370295, 0.38748123123123124, 0.39381153305203936, 0.40031152647975077, 0.4073986804901037, 0.4144058885383807, 0.42117376294591485, 0.4278996865203762, 0.4345196959225985, 0.44109160855974994, 0.44783983140147526, 0.4545929018789144, 0.4612676056338028, 0.46842105263157896, 0.47580645161290325, 0.4835063009636768, 0.4918300653594771, 0.5005494505494505, 0.5103828682673589, 0.5201078960274644, 0.5301974448315911, 0.5394021739130435, 0.5483870967741935, 0.5566914498141264, 0.5653252480705623, 0.5745850829834033, 0.5841357727491574, 0.593939393939394, 0.6039870689655172, 0.6143467900196243, 0.6247243863001617, 0.6354556803995006, 0.6463059918557301, 0.6572863148061654, 0.6680457532246289, 0.6785714285714286, 0.687829525483304, 0.6968702675416456, 0.706344410876133, 0.7169101372288623, 0.7281270252754375, 0.7395327942497754, 0.7564269818126007, 0.7743538767395626, 0.7913293637519234, 0.8059529303184125, 0.8264411027568922, 0.8488441909336536, 0.8649468892261002, 0.8776902887139107, 0.8925925925925926, 0.916051040967092, 0.9327971403038428, 0.9642994241842611),
(0.01006036217303823, 0.01950354609929078, 0.02763157894736842, 0.03734276729559748, 0.046703296703296704, 0.055505004549590536, 0.06485148514851485, 0.0744047619047619, 0.08384710234278668, 0.09315068493150686, 0.1025974025974026, 0.11226252158894647, 0.12214342001576044, 0.13169642857142858, 0.14135606661379857, 0.15093936806148592, 0.16034482758620688, 0.17032967032967034, 0.18041704442429737, 0.19052631578947368, 0.20015220700152206, 0.21035058430717862, 0.2196969696969697, 0.22911051212938005, 0.23842953718148727, 0.24842072015161087, 0.2581818181818182, 0.26833740831295844, 0.27846975088967973, 0.28846153846153844, 0.2984423676012461, 0.30812641083521447, 0.3176470588235294, 0.3277126099706745, 0.3380829015544041, 0.3495388162951576, 0.3602150537634409, 0.3709677419354839, 0.3813131313131313, 0.39094090202177295, 0.4005364327223961, 0.4097301406309388, 0.4192900200937709, 0.4298780487804878, 0.44074074074074077, 0.45153933865450396, 0.46206896551724136, 0.4725050916496945, 0.4832102081934184, 0.49411764705882355, 0.5044709388971684, 0.5160024154589372, 0.5273851590106007, 0.5384615384615384, 0.5492135971588027, 0.5594956658786446, 0.5695687550854354, 0.5789473684210527, 0.5883143049026192, 0.5980582524271845, 0.608355091383812, 0.6193952033368092, 0.6312217194570136, 0.6435995623632386, 0.6555891238670695, 0.6666666666666666, 0.6774033696729435, 0.687603993344426, 0.6979717813051146, 0.7083333333333334, 0.7186364906398436, 0.7296222664015904, 0.7409050576752441, 0.7519685039370079, 0.7632200188857413, 0.7734138972809668, 0.7821803852889667, 0.7908950617283951, 0.8, 0.8105343901815393, 0.8221635883905013, 0.8335365853658536, 0.8464403066812706, 0.8577929465301479, 0.8672809956917186, 0.8779892630551489, 0.8868433971526755, 0.8937638649248213, 0.9005102040816326, 0.9098214285714286, 0.9207258834765998, 0.9329032258064516, 0.9447368421052632, 0.9541564792176039, 0.9634146341463414, 0.9743589743589743, 0.9842668344870988, 0.988835725677831, 0.9980525803310614))


def fuzzynode(street, player, exp, stack, pot):
    """Calculates indices of node"""
    cost = stack[player] - stack[1 - player]
    potodds = cost / (pot + cost)
    nodeind = 2500 * street
    for ind in range(99):
        if exp <= EVBUCKETS[street][ind]:
            nodeind += 25 * ind
            break
        if ind == 98:
            nodeind += 25 * 99
    bucket1 = []
    if pot >= 250:
        bucket1.append([20, 1.0])
    elif pot >= 160:
        bucket1.append([20, (pot - 160) / 90.0])
        bucket1.append([15, (250 - pot) / 90.0])
    elif pot >= 90:
        bucket1.append([15, (pot - 90) / 70.0])
        bucket1.append([10, (160 - pot) / 70.0])
    elif pot >= 40:
        bucket1.append([10, (pot - 40) / 50.0])
        bucket1.append([5, (90 - pot) / 50.0])
    elif pot >= 10:
        bucket1.append([5, (pot - 10) / 30.0])
        bucket1.append([0, (40 - pot) / 30.0])
    else:
        bucket1.append([0, 1.0])
    bucket2 = []
    if potodds >= 0.45:
        bucket2.append([4, 1.0])
    elif potodds >= 0.4:
        bucket2.append([4, (potodds - 0.4) * 20.0])
        bucket2.append([3, (0.45 - potodds) * 20.0])
    elif potodds >= 0.3:
        bucket2.append([3, (potodds - 0.3) * 10.0])
        bucket2.append([2, (0.4 - potodds) * 10.0])
    elif potodds >= 0.2:
        bucket2.append([2, (potodds - 0.2) * 10.0])
        bucket2.append([1, (0.3 - potodds) * 10.0])
    elif potodds >= 0.1:
        bucket2.append([1, (potodds - 0.1) * 10.0])
        bucket2.append([0, (0.2 - potodds) * 10.0])
    else:
        bucket2.append([0, 1.0])
    nodeinds = []
    for mix1 in bucket1:
        for mix2 in bucket2:
            nodeinds.append([nodeind + mix1[0] + mix2[0], mix1[1] * mix2[1]])
    return nodeinds


def showdownev(stakes, exp1, exp2):
    """EV if game goes to showdown"""
    if (exp1 == 1 and exp2 == 1) or (exp1 == 0 and exp2 == 0):
        return 0
    return stakes * (exp1 - exp2) / (exp1 + exp2 - 2 * exp1 * exp2)


def proceed(nodes, street, button, exps, stack, pot, minraise, p):
    """Chooses one course of action to pursue"""
    player = button % 2
    opp = 1 - player
    if stack[player] == 0:
        return pot, minraise
    nodeinds = fuzzynode(street, player, exps[player], stack, pot)
    strat = [0.0] * NUM_ACTIONS
    util = [0.0] * NUM_ACTIONS
    nodeutil = 0.0
    for ind in range(NUM_ACTIONS):
        for data in nodeinds:
            tmpstrat = nodes[data[0]].getstrat()
            strat[ind] += tmpstrat[ind] * data[1]
            nodes[data[0]].stratsum[ind] += tmpstrat[ind] * data[1] * p[int(player == 1)]
        if ind == 0:  # fold
            util[ind] = stack[player] - 200
        elif ind == 1:  # check/call
            util[ind] = showdownev(stack[opp], exps[player], exps[opp])
        else:
            tmpstack = list(stack)
            tmppot = pot
            if ind == 2:  # min bet/raise
                bet = min(minraise + stack[player] - stack[opp], stack[player])
            elif ind == 3:  # 2x min bet/raise
                bet = min(2 * minraise + stack[player] - stack[opp], stack[player])
            elif ind == 4:  # half pot
                bet = min(max(10 + stack[player] - stack[opp], minraise + stack[player] - stack[opp], 3 * (200 - stack[opp])), stack[player])
            elif ind == 5:  # all in
                bet = stack[player]
            tmpstack[player] -= bet
            tmppot += bet
            oppnodeinds = fuzzynode(street, opp, exps[opp], tmpstack, tmppot)
            oppfold = 0.0
            for data in oppnodeinds:
                oppfold += nodes[data[0]].getstrat()[0] * data[1]
            potexp = min(200, 200 - tmpstack[player] + 30 * (4 - street) * exps[player] * exps[opp])
            util[ind] = (oppfold * (200 - stack[opp]) + (1 - oppfold) * showdownev(potexp, exps[player], exps[opp])) * p[int(player == 1)]
        nodeutil += strat[ind] * util[ind]
    for ind in range(NUM_ACTIONS):
        regret = util[ind] - nodeutil
        for data in nodeinds:
            nodes[data[0]].regretsum[ind] += regret * data[1] * p[int(player == 0)]
    # print(nodeinds, strat)
    choice = 0
    sample = random.random() - strat[choice]
    while sample > 0.0001:
        choice += 1
        sample -= strat[choice]
    p[int(player == 1)] *= strat[choice]
    if choice < 2:  # check/call
        bet = stack[player] - stack[opp]
    elif choice == 2:  # min bet/raise
        bet = min(minraise + stack[player] - stack[opp], stack[player])
    elif choice == 3:  # 2x min bet/raise
        bet = min(2 * minraise + stack[player] - stack[opp], stack[player])
        minraise *= 2
    elif choice == 4:  # half pot
        bet = min(max(minraise + stack[player] - stack[opp], 3 * (200 - stack[opp])), stack[player])
        minraise = 200 - stack[opp]
    elif choice == 5:  # all in
        bet = stack[player]
        minraise = stack[opp]
    stack[player] -= bet
    pot += bet
    return pot, minraise


def playdiscards(deck, nodes, ev, preflop):
    """Plays two hands with discards"""
    random.shuffle(deck)
    hole, board = [deck[:2], deck[2:4]], deck[4:7]
    stack, pot, p = [199, 198], 3, [1.0, 1.0]
    exps, button, minraise = [baseline.preflopexp(hole[0], preflop), baseline.preflopexp(hole[1], preflop)], 0, 2
    while button < 2 or stack[0] != stack[1]:
        pot, minraise = proceed(nodes, 0, button, exps, stack, pot, minraise, p)
        button += 1
    exps, button, minraise = [baseline.evexp(board, hole[0], ev), baseline.evexp(board, hole[1], ev)], 1, 2
    while button < 3 or stack[0] != stack[1]:
        pot, minraise = proceed(nodes, 1, button, exps, stack, pot, minraise, p)
        button += 1
    for ind in range(2):
        toss = discard.flop(board, hole[ind], 1)
        if toss is not None:
            if toss == hole[ind][0]:
                hole[ind][0] = deck[9 + ind]
            elif toss == hole[ind][1]:
                hole[ind][1] = deck[9 + ind]
    board = deck[4:8]
    exps, button, minraise = [baseline.evexp(board, hole[0], ev), baseline.evexp(board, hole[1], ev)], 1, 2
    while button < 3 or stack[0] != stack[1]:
        pot, minraise = proceed(nodes, 2, button, exps, stack, pot, minraise, p)
        button += 1
    for ind in range(2):
        toss = discard.turn(board, hole[ind], 1)
        if toss is not None:
            if toss == hole[ind][0]:
                hole[ind][0] = deck[11 + ind]
            elif toss == hole[ind][1]:
                hole[ind][1] = deck[11 + ind]
    board = deck[4:9]
    exps, button, minraise = [baseline.evexp(board, hole[0], ev), baseline.evexp(board, hole[1], ev)], 1, 2
    while button < 3 or stack[0] != stack[1]:
        pot, minraise = proceed(nodes, 3, button, exps, stack, pot, minraise, p)
        button += 1


def simplecfr(nodes, street, button, exps, stack, pot, minraise, p):
    """One betting decision"""
    player = button % 2
    opp = 1 - player
    # return payoff for terminal states
    if stack[0] == stack[1] and ((street == 0 and button > 1) or (street > 0 and button > 2)):
        return (200 - stack[0]) * (exps[player] - exps[opp]) / (exps[player] + exps[opp] - 2 * exps[player] * exps[opp])
    # for each action, recursively call cfr with additional history and probability
    nodeind = findnode(street, player, exps[player], stack, pot)
    strat = nodes[nodeind].getstrat(p[int(player == 1)])
    util = [0.0] * NUM_ACTIONS
    nodeutil = 0.0
    if (street == 0 and button > 3) or (street > 0 and button > 4):
        for ind in range(NUM_ACTIONS):
            if player == 0:
                tmpp = [p[0] * strat[ind], p[1]]
            else:
                tmpp = [p[0], p[1] * strat[ind]]
            if ind == 0:  # fold
                util[ind] = stack[player] - 200
            else:  # stop recursion at depth 5
                util[ind] = simplecfr(nodes, street, button + 1, exps, [stack[opp], stack[opp]], pot + stack[player] - stack[opp], minraise, tmpp)
            nodeutil += strat[ind] * util[ind]
    else:
        for ind in range(NUM_ACTIONS):
            if ind == 0:  # fold
                util[ind] = stack[player] - 200
            else:
                tmpstack = list(stack)
                tmppot = pot
                tmpminraise = minraise
                if player == 0:
                    tmpp = [p[0] * strat[ind], p[1]]
                else:
                    tmpp = [p[0], p[1] * strat[ind]]
                if ind == 1:  # check/call
                    bet = stack[player] - stack[opp]
                elif ind == 2:  # min bet/raise
                    bet = min(minraise + stack[player] - stack[opp], stack[player])
                elif ind == 3:  # 2x min bet/raise
                    bet = min(2 * minraise + stack[player] - stack[opp], stack[player])
                    tmpminraise = 2 * minraise
                elif ind == 4:  # half pot
                    bet = min(max(10 + stack[player] - stack[opp], minraise + stack[player] - stack[opp], 3 * (200 - stack[opp])), stack[player])
                    tmpminraise = bet - (stack[player] - stack[opp])
                elif ind == 5:  # all in
                    bet = stack[player]
                    tmpminraise = stack[opp]
                tmpstack[player] -= bet
                tmppot += bet
                util[ind] = simplecfr(nodes, street, button + 1, exps, tmpstack, tmppot, tmpminraise, tmpp)
            nodeutil += strat[ind] * util[ind]
    for ind in range(NUM_ACTIONS):
        regret = util[ind] - nodeutil
        nodes[nodeind].regretsum[ind] += p[int(player == 0)] * regret
        if nodes[nodeind].regretsum[ind] < 0:
            nodes[nodeind].regretsum[ind] = 0
    return nodeutil
